<!doctype html>
<html lang="pt-BR">
<head>
  <!-- Define a codificação de caracteres como UTF-8 para suportar acentos e caracteres especiais -->
  <meta charset="utf-8"/>
  
  <!-- Configura a viewport para dispositivos móveis: largura igual ao dispositivo e escala inicial 1 -->
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  
  <!-- Título da página exibido na aba do navegador -->
  <title>Cobrinha — Versão Aprimorada</title>

  <!-- Estilos CSS embutidos para layout, cores, responsividade e elementos visuais do jogo -->
  <style>
    /* Define variáveis CSS para cores e estilos reutilizáveis */
    :root{
      --bg1:#071422; /* Cor de fundo superior do gradiente */
      --bg2:#051718; /* Cor de fundo inferior do gradiente */
      --ui:#e6f4ea;  /* Cor de texto e elementos de interface */
      --accent:#16a34a; /* Cor de destaque (botões, ações) */
    }

    /* Aplica box-sizing border-box a todos os elementos para facilitar cálculos de layout */
    *{box-sizing:border-box}

    /* Estilo da página inteira: altura 100%, sem margem, fonte moderna, gradiente de fundo e cor de texto */
    html,body{
      height:100%; 
      margin:0; 
      font-family:Inter,Arial,Helvetica,sans-serif; 
      background:linear-gradient(180deg,var(--bg1) 0%,var(--bg2) 100%); 
      color:var(--ui);
    }

    /* Container centralizado vertical e horizontalmente com padding */
    #container{
      min-height:100vh; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
      padding:24px;
    }

    /* Agrupa elementos do jogo (HUD, canvas, controles) em coluna centralizada */
    .stage{
      position:relative; 
      display:flex; 
      flex-direction:column; 
      align-items:center; 
      gap:12px;
    }

    /* Estilo do canvas do jogo: bordas arredondadas, sombra, fundo escuro, pixelado */
    canvas#game{
      border-radius:10px; 
      box-shadow:0 10px 40px rgba(0,0,0,0.6); 
      border:4px solid rgba(255,255,255,0.04); 
      background:#071a0f; 
      image-rendering:pixelated; 
      display:block;
    }

    /* Barra de HUD (Heads-Up Display) com pontuação, vidas e recorde */
    #hud{
      display:flex; 
      gap:14px; 
      align-items:center; 
      font-weight:700; 
      z-index:4; 
      user-select:none; /* Impede seleção de texto */
    }

    /* Estilo de cada item do HUD (ex: "Pontos: 0") */
    .hud-item{
      background:rgba(255,255,255,0.03); 
      padding:8px 12px; 
      border-radius:8px;
    }

    /* Contêiner dos botões de controle */
    .controls{
      display:flex; 
      gap:8px; 
      align-items:center;
    }

    /* Estilo dos botões (primário e secundário) */
    button, .btn{
      padding:8px 12px; 
      border-radius:8px; 
      border:none; 
      background:var(--accent); 
      color:#fff; 
      font-weight:700; 
      cursor:pointer; 
      box-shadow:0 6px 18px rgba(0,0,0,0.45);
    }
    button.secondary{
      background:#0ea5a6; /* Cor alternativa */
    }

    /* Overlay (tela de sobreposição) para mensagens, início e pausa */
    .overlay{
      position:absolute; 
      top:0; 
      left:0; 
      width:100%; 
      height:100%; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
      flex-direction:column; 
      gap:12px; 
      background:rgba(0,0,0,0.45); 
      border-radius:8px; 
      text-align:center; 
      padding:18px; 
      z-index:6; 
      pointer-events:auto; /* Permite interação */
    }

    /* Classe para esconder elementos (display: none) */
    .hidden{display:none}

    /* Estilo do título na tela inicial */
    #start-screen h1{
      margin:0; 
      font-size:28px
    }

    /* Classe para textos menores e com opacidade reduzida */
    .small{
      font-size:12px; 
      opacity:0.9
    }

    /* Estilo do elemento de mensagem clicável */
    #msg{cursor:pointer}

    /* Painel de configurações (velocidade, volume) */
    .settings-panel{
      position:relative; 
      display:flex; 
      gap:8px; 
      align-items:center;
    }

    /* Slider de configuração (range input) */
    input[type=range]{width:120px}

    /* Painel do leaderboard (placar de recordes) */
    #leaderboard{
      max-height:220px; 
      overflow:auto; 
      width:220px; 
      text-align:left; 
      background:rgba(255,255,255,0.03); 
      padding:8px; 
      border-radius:8px
    }

    /* Classe para elementos "mutados" (ex: ícones de áudio desligado) */
    .muted{opacity:0.5}

    /* Rodapé com texto pequeno */
    footer.small{
      margin-top:6px; 
      opacity:0.8
    }
    
    /* ================================
       ESTILOS PARA CONTROLES TOUCH (MOBILE)
       ================================ */
    .touch-controls {
      display: none; /* Escondido por padrão, aparece apenas em telas menores */
      position: relative;
      width: 100%;
      margin-top: 20px;
      touch-action: none; /* Previne comportamentos padrão de toque (zoom, scroll) */
      user-select: none; /* Impede seleção de texto */
    }
    
    /* D-Pad (direcional virtual) */
    .d-pad {
      position: absolute;
      left: 20px;
      bottom: 20px;
      width: 120px;
      height: 120px;
    }
    
    /* Botões individuais do D-Pad */
    .d-pad-button {
      position: absolute;
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 20px;
    }
    
    /* Posicionamento dos botões do D-Pad */
    .d-pad-up { top: 0; left: 40px; }
    .d-pad-down { bottom: 0; left: 40px; }
    .d-pad-left { top: 40px; left: 0; }
    .d-pad-right { top: 40px; right: 0; }
    
    /* Botões de ação (Pausar, Reiniciar) */
    .action-buttons {
      position: absolute;
      right: 20px;
      bottom: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .action-button {
      width: 60px;
      height: 60px;
      border-radius: 50%; /* Forma circular */
      background: rgba(22, 163, 74, 0.7); /* Verde translúcido */
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 16px;
    }
    
    /* ================================
       MEDIA QUERIES - RESPONSIVIDADE
       ================================ */
    @media (max-width: 900px) {
      #container {
        padding: 10px;
        align-items: flex-start; /* Alinha ao topo em telas menores */
        padding-top: 20px;
      }
      
      .stage {
        width: 100%;
        max-width: 500px; /* Limita largura máxima */
      }
      
      canvas#game {
        width: 100% !important;
        height: auto !important;
        max-height: 50vh; /* Limita altura em telas menores */
      }
      
      #hud {
        flex-direction: column; /* Empilha os itens do HUD verticalmente */
        gap: 8px;
        width: 100%;
      }
      
      .controls {
        flex-wrap: wrap; /* Permite que botões quebrem linha */
        justify-content: center;
      }
      
      .settings-panel {
        flex: 1;
        min-width: 45%;
        justify-content: center;
      }
      
      input[type=range] {
        width: 100%; /* Slider ocupa toda a largura disponível */
      }
      
      #leaderboard {
        width: 100%;
        max-height: 120px; /* Reduz altura do placar */
      }
      
      .touch-controls {
        display: block; /* Mostra controles touch em telas menores */
      }
      
      #start-screen h1 {
        font-size: 24px; /* Título menor */
      }
    }
    
    @media (max-width: 600px) {
      .controls {
        flex-direction: column; /* Empilha botões verticalmente */
      }
      
      .settings-panel {
        min-width: 100%; /* Ocupa toda a largura */
      }
      
      /* Reduz tamanho do D-Pad */
      .d-pad {
        width: 100px;
        height: 100px;
        left: 10px;
        bottom: 10px;
      }
      
      .d-pad-button {
        width: 30px;
        height: 30px;
        font-size: 16px;
      }
      
      /* Ajusta posicionamento dos botões do D-Pad */
      .d-pad-up { left: 35px; }
      .d-pad-down { left: 35px; }
      .d-pad-left { top: 35px; }
      .d-pad-right { top: 35px; }
      
      .action-buttons {
        right: 10px;
        bottom: 10px;
      }
      
      .action-button {
        width: 50px;
        height: 50px;
      }
    }
    
    @media (max-width: 400px) {
      #start-screen h1 {
        font-size: 20px;
      }
      
      .hud-item {
        padding: 6px 10px;
        font-size: 14px;
      }
      
      button, .btn {
        padding: 6px 10px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <!-- Container principal do jogo -->
  <div id="container">
    <div class="stage">
      <!-- HUD: exibe pontuação, vidas e recorde -->
      <div id="hud">
        <div class="hud-item">Pontos: <span id="score">0</span></div>
        <div class="hud-item">Vidas: <span id="lives">3</span></div>
        <div class="hud-item">Recorde: <span id="highscore">0</span></div>
        
        <!-- Controles: botões e sliders -->
        <div class="controls">
          <button id="pauseBtn" class="secondary">Pausar(Clique P ou Esc)</button>
          <button id="muteBtn">Música: On</button>
          
          <!-- Controle de velocidade -->
          <div class="settings-panel">
            <label class="small">Velocidade</label>
            <input id="speedRange" type="range" min="6" max="18" value="10"/>
          </div>
          
          <!-- Controle de volume -->
          <div class="settings-panel">
            <label class="small">Volume</label>
            <input id="volRange" type="range" min="0" max="1" step="0.05" value="0.6"/>
          </div>
        </div>
      </div>

      <!-- Canvas onde o jogo é renderizado -->
      <canvas id="game"></canvas>
      
      <!-- Controles touch para dispositivos móveis (escondidos em desktop) -->
      <div class="touch-controls">
        <div class="d-pad">
          <div class="d-pad-button d-pad-up">↑</div>
          <div class="d-pad-button d-pad-down">↓</div>
          <div class="d-pad-button d-pad-left">←</div>
          <div class="d-pad-button d-pad-right">→</div>
        </div>
        <div class="action-buttons">
          <div class="action-button" id="touchPause">P</div>
          <div class="action-button" id="touchRestart">R</div>
        </div>
      </div>

      <!-- Tela inicial (overlay) -->
      <div id="start-screen" class="overlay">
        <h1>Jogo da Cobrinha</h1>
        <p>Use setas / WASD / swipe (mobile). P / Esc para pausar. M para mute. Clique em Start.</p>
        <div style="display:flex;gap:8px">
          <button id="startBtn">Start</button>
          <button id="howBtn" class="secondary">Como Jogar</button>
        </div>
        <div style="display:flex; gap:12px; margin-top:8px; align-items:center;">
          <div id="leaderboard" aria-live="polite">
            <strong>Top local</strong><div id="lb-list" class="small"></div>
          </div>
        </div>
        <footer class="small">Preferências salvas localmente.</footer>
      </div>

      <!-- Overlay de mensagens temporárias (Game Over, Vitória, etc) -->
      <div id="msg" class="overlay hidden"></div>
    </div>
  </div>

  <!-- Script JavaScript com toda a lógica do jogo -->
  <script>
    /* Constantes de tamanho base do canvas (usado para cálculos de escala) */
    const CSS_WIDTH = 800, CSS_HEIGHT = 600;

    /* Referências a elementos do DOM */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', {alpha:false}); // Contexto 2D sem transparência
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const highscoreEl = document.getElementById('highscore');
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('startBtn');
    const howBtn = document.getElementById('howBtn');
    const msg = document.getElementById('msg');
    const pauseBtn = document.getElementById('pauseBtn');
    const muteBtn = document.getElementById('muteBtn');
    const speedRange = document.getElementById('speedRange');
    const volRange = document.getElementById('volRange');
    const lbList = document.getElementById('lb-list');

    /* Referências aos botões touch */
    const touchPauseBtn = document.getElementById('touchPause');
    const touchRestartBtn = document.getElementById('touchRestart');
    const dpadUp = document.querySelector('.d-pad-up');
    const dpadDown = document.querySelector('.d-pad-down');
    const dpadLeft = document.querySelector('.d-pad-left');
    const dpadRight = document.querySelector('.d-pad-right');

    /* Chaves para armazenamento local (localStorage) */
    const STORAGE = {
      HS: 'snake_highscore_v2',      // Recorde
      PREF: 'snake_prefs_v1',        // Preferências (volume, mute, velocidade)
      LB: 'snake_leaderboard_v1',    // Leaderboard (placar)
    };

    /* Objeto de preferências do usuário */
    let prefs = { 
      muted: false,        // Áudio mutado?
      volume: 0.6,         // Volume (0 a 1)
      baseFPS: 10          // Velocidade base (frames por segundo)
    };

    /* Variáveis de jogo */
    let SCALE = 20;        // Tamanho de cada quadrado da grade
    let COLS, ROWS;        // Número de colunas e linhas do grid
    let snake = [];        // Array de segmentos da cobra (cada segmento = {x,y})
    let dir = {x:0,y:0},   // Direção atual da cobra
        nextDir = {x:0,y:0}; // Próxima direção (para evitar colisão com a própria cauda)
    let food = {x:0,y:0};  // Posição da comida
    let score = 0,         // Pontuação atual
        lives = 3,         // Vidas restantes
        highscore = 0;     // Melhor pontuação
    let running = false;   // Jogo em execução?
    let invincibleUntil = 0; // Tempo até o fim da invencibilidade (após perder vida)
    let lastTimestamp = 0; // Último timestamp da animação

    /* Fixed timestep (para atualizações consistentes independentes do FPS) */
    let accumulator = 0;   // Acumulador de tempo
    let timestep = 1000/10; // Intervalo de tempo entre updates (em ms)

    /* Canvas offscreen para desenhar o tabuleiro de xadrez (otimização) */
    let bgCanvas, bgCtx;

    /* Sons do jogo */
    let bgMusic, eatSound, gameOverSound, winSound;

    /* Leaderboard (array de objetos {score, date}) */
    let leaderboard = [];

    /* =======================
       Funções de Utilidade
       ======================= */

    /* Gera número inteiro aleatório entre min e max (inclusivo) */
    function randInt(min,max){ 
      return Math.floor(Math.random()*(max-min+1))+min; 
    }

    /* Retorna timestamp atual em milissegundos */
    function now(){ 
      return performance.now(); 
    }

    /* Salva preferências no localStorage */
    function savePrefs(){ 
      localStorage.setItem(STORAGE.PREF, JSON.stringify(prefs)); 
    }

    /* Carrega preferências do localStorage */
    function loadPrefs(){ 
      try{ 
        const p = JSON.parse(localStorage.getItem(STORAGE.PREF)); 
        if(p) prefs = {...prefs, ...p}; // Mescla com defaults
      }catch(e){} // Ignora erros
    }

    /* Carrega recorde do localStorage */
    function loadHS(){ 
      highscore = +localStorage.getItem(STORAGE.HS) || 0; 
      highscoreEl.textContent = highscore; 
    }

    /* Salva recorde no localStorage */
    function saveHS(){ 
      localStorage.setItem(STORAGE.HS, highscore); 
      highscoreEl.textContent = highscore; 
    }

    /* Carrega leaderboard do localStorage */
    function loadLeaderboard(){ 
      try{ 
        leaderboard = JSON.parse(localStorage.getItem(STORAGE.LB))||[]; 
      }catch(e){ 
        leaderboard=[]; 
      } 
      renderLeaderboard(); 
    }

    /* Salva leaderboard no localStorage */
    function saveLeaderboard(){ 
      localStorage.setItem(STORAGE.LB, JSON.stringify(leaderboard)); 
      renderLeaderboard(); 
    }

    /* Adiciona nova pontuação ao leaderboard e mantém top 10 */
    function addToLeaderboard(scoreVal){ 
      leaderboard.push({score:scoreVal, date:(new Date()).toISOString()});
      leaderboard.sort((a,b)=>b.score-a.score); // Ordena decrescente
      leaderboard = leaderboard.slice(0,10);     // Mantém apenas top 10
      saveLeaderboard(); 
    }

    /* =======================
       Configuração do Canvas (Responsivo)
       ======================= */

    /* Ajusta tamanho do canvas com base na largura da tela e densidade de pixels */
    function setupCanvas(){
      const dpr = window.devicePixelRatio || 1; // Densidade de pixels do dispositivo
      
      // Calcula largura máxima (respeitando margens laterais)
      const maxWidth = Math.min(CSS_WIDTH, window.innerWidth - 40);
      const aspectRatio = CSS_HEIGHT / CSS_WIDTH; // Proporção original
      const calculatedHeight = maxWidth * aspectRatio; // Altura proporcional
      
      // Aplica estilos CSS
      canvas.style.width = maxWidth + 'px';
      canvas.style.height = calculatedHeight + 'px';
      
      // Define tamanho real do canvas (considerando densidade de pixels)
      canvas.width = Math.floor(maxWidth * dpr);
      canvas.height = Math.floor(calculatedHeight * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // Escala o contexto para renderizar corretamente
      
      // Recalcula grid com base no novo tamanho
      SCALE = 20 * (maxWidth / CSS_WIDTH); // Escala proporcional
      COLS = Math.floor(maxWidth / SCALE);
      ROWS = Math.floor(calculatedHeight / SCALE);
      
      // Cria canvas offscreen para o tabuleiro
      bgCanvas = document.createElement('canvas');
      bgCanvas.width = maxWidth;
      bgCanvas.height = calculatedHeight;
      bgCtx = bgCanvas.getContext('2d');
      drawChessboardToCache(); // Desenha o tabuleiro uma vez
    }

    /* Desenha o tabuleiro de xadrez (alternando cores) no canvas offscreen */
    function drawChessboardToCache(){
      const s = SCALE;
      for(let y=0;y<ROWS;y++){
        for(let x=0;x<COLS;x++){
          bgCtx.fillStyle=(x+y)%2===0?'#f9f2e7':'#eee1c6'; // Cores alternadas
          bgCtx.fillRect(x*s, y*s, s, s);
        }
      }
    }

    /* =======================
       Configuração de Áudio
       ======================= */

    /* Inicializa os sons do jogo */
    function setupAudio(){
      bgMusic = new Audio('snak.mp3'); 
      bgMusic.loop = true; 
      bgMusic.volume = prefs.volume;
      
      // Sons de efeito (URLs públicas)
      eatSound = new Audio('https://actions.google.com/sounds/v1/cartoon/pop.ogg  '); 
      eatSound.volume = 1.0;
      gameOverSound = new Audio('https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg  '); 
      gameOverSound.volume = 1.0;
      winSound = new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg  '); 
      winSound.volume = 1.0;
      
      applyAudioPrefs(); // Aplica preferências de volume/mute
      
      // Preload e tratamento de erros
      [bgMusic,eatSound,gameOverSound,winSound].forEach(a=>{
        a.preload = 'auto';
        a.addEventListener('error', ()=>{});
      });
    }

    /* Aplica preferências de áudio (volume e mute) */
    function applyAudioPrefs(){
      try{
        const vol = +prefs.volume;
        // Ajusta volume dos sons de efeito
        [eatSound,gameOverSound,winSound].forEach(s=>s.volume = Math.min(1, Math.max(0, vol)));
        // Ajusta volume da música (mais baixo)
        if(bgMusic) bgMusic.volume = vol * 0.6;
        updateMuteButton(); // Atualiza texto do botão
      }catch(e){}
    }

    /* Reproduz um som (se não estiver mutado) */
    function playSound(snd){
      if(prefs.muted) return; // Não toca se mutado
      try{ 
        snd.currentTime = 0; 
        snd.play().catch(()=>{}); // Ignora erros de reprodução
      }catch(e){}
    }

    /* =======================
       Lógica do Jogo
       ======================= */

    const INITIAL_LIVES = 3;   // Vidas iniciais
    const POINTS_PER_FOOD = 10; // Pontos por comida

    /* Reinicia a cobra (posição inicial) */
    function resetSnake(){
      snake = [];
      const startX = Math.floor(COLS/2);
      const startY = Math.floor(ROWS/2);
      // Cria 4 segmentos iniciais (cabeça + corpo)
      for(let i=0;i<4;i++) snake.push({x:startX-i, y:startY});
      dir = {x:1,y:0};     // Começa indo para a direita
      nextDir = {x:1,y:0};
    }

    /* Gera comida em posição aleatória (não sobre a cobra) */
    function spawnFood(){
      let tries=0;
      do{
        food.x = randInt(0,COLS-1);
        food.y = randInt(0,ROWS-1);
        tries++;
        if(tries>2000) break; // Evita loop infinito
      }while(snake.some(s=>s.x===food.x && s.y===food.y)); // Verifica colisão com cobra
    }

    /* Atualiza estado do jogo (movimento, colisões, crescimento) */
    function update(){
      // Evita que a cobra vire na direção oposta (colisão com si mesma)
      if(!(nextDir.x === -dir.x && nextDir.y === -dir.y)) dir = nextDir;
      
      // Calcula nova cabeça
      const newHead = {x:snake[0].x + dir.x, y:snake[0].y + dir.y};
      
      // Verifica colisão com paredes ou com o próprio corpo
      const outOfBounds = newHead.x < 0 || newHead.x >= COLS || newHead.y < 0 || newHead.y >= ROWS;
      const collidedWithSelf = snake.some(s=>s.x===newHead.x && s.y===newHead.y);
      
      // Se colidiu e não está invencível, perde vida
      if((outOfBounds || collidedWithSelf) && now() > invincibleUntil){
        loseLife();
        return;
      }
      
      // Adiciona nova cabeça
      snake.unshift(newHead);
      
      // Se comeu comida
      if(newHead.x === food.x && newHead.y === food.y){
        score += POINTS_PER_FOOD;
        scoreEl.textContent = score;
        playSound(eatSound); // Toca som
        try{ navigator.vibrate && navigator.vibrate(40); }catch(e){} // Vibração (mobile)
        spawnFood(); // Gera nova comida
      } else {
        snake.pop(); // Remove cauda (se não comeu)
      }
      
      // Verifica vitória (cobra preenche quase todo o tabuleiro)
      if(snake.length >= COLS*ROWS - 1){
        handleWin();
      }
    }

    /* Lida com perda de vida */
    function loseLife(){
      running = false; // Pausa jogo
      lives--;         // Diminui vida
      livesEl.textContent = lives; // Atualiza HUD
      playSound(gameOverSound); // Toca som
      
      if(lives > 0){
        // Mostra mensagem e reinicia após 1 segundo
        showTempMessage(`Você perdeu uma vida! Vidas: ${lives}`, 1000, ()=>{
          resetSnake(); 
          spawnFood();
          invincibleUntil = now() + 1500; // Invencibilidade por 1.5s
          running = true;
        });
      } else {
        // Game Over
        if(score > highscore){ 
          highscore = score; 
          saveHS(); // Salva novo recorde
        }
        addToLeaderboard(score); // Adiciona ao placar
        showMessage(`Game Over! Pontos: ${score}`, false);
      }
    }

    /* Lida com vitória */
    function handleWin(){
      running = false;
      playSound(winSound);
      if(score > highscore){ 
        highscore = score; 
        saveHS(); 
      }
      addToLeaderboard(score);
      showMessage(`Você venceu! Pontos: ${score}`, true);
    }

    /* =======================
       Renderização
       ======================= */

    let blinkState = true;   // Estado de piscar dos olhos
    let mouthOpen = true;    // Boca aberta/fechada
    let animTimer = 0;       // Contador para animações

    /* Renderiza um frame do jogo */
    function render(interp){
      // Desenha tabuleiro de fundo
      ctx.drawImage(bgCanvas, 0, 0, canvas.style.width.replace('px', ''), canvas.style.height.replace('px', ''));

      // Desenha comida (círculo vermelho com detalhes)
      const fx = food.x * SCALE + SCALE/2;
      const fy = food.y * SCALE + SCALE/2;
      ctx.fillStyle = '#ff4c4c';
      ctx.beginPath(); 
      ctx.arc(fx, fy, SCALE*0.4, 0, Math.PI*2); 
      ctx.fill();
      ctx.strokeStyle = '#2b5d34'; 
      ctx.lineWidth = 2;
      ctx.beginPath(); 
      ctx.moveTo(fx, fy - SCALE*0.4); 
      ctx.lineTo(fx, fy - SCALE*0.6); 
      ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.beginPath();
      ctx.arc(fx - SCALE*0.15, fy - SCALE*0.15, SCALE*0.1, 0, Math.PI*2); 
      ctx.fill();

      // Desenha cobra
      for(let i=0;i<snake.length;i++){
        const part = snake[i];
        const px = part.x * SCALE;
        const py = part.y * SCALE;
        
        if(i === 0){ // Cabeça
          ctx.fillStyle = '#9fffa3';
          ctx.fillRect(px, py, SCALE, SCALE);
          ctx.fillStyle = '#000';
          // Olhos (pisca)
          if(blinkState){
            ctx.fillRect(px + 4, py + 4, 3, 3);
            ctx.fillRect(px + SCALE - 7, py + 4, 3, 3);
          }
          // Boca (abre/fecha)
          ctx.fillRect(px + 6, py + SCALE - (mouthOpen?7:6), 4, 1);
          // Sombra inferior
          ctx.fillStyle = 'rgba(0,0,0,0.12)';
          ctx.fillRect(px, py + SCALE - 2, SCALE, 2);
        } else { // Corpo
          ctx.fillStyle = '#28a745';
          ctx.fillRect(px, py, SCALE, SCALE);
          ctx.strokeStyle = '#1c7c32';
          ctx.beginPath();
          // Padrão de listras diagonais (animação)
          if((i + animTimer) % 2 === 0){
            ctx.moveTo(px, py); 
            ctx.lineTo(px + SCALE, py + SCALE);
          } else {
            ctx.moveTo(px + SCALE, py); 
            ctx.lineTo(px, py + SCALE);
          }
          ctx.stroke();
        }
      }

      // Efeito de invencibilidade (sobreposição branca translúcida)
      if(now() < invincibleUntil){
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        ctx.fillRect(0,0,canvas.style.width.replace('px', ''),canvas.style.height.replace('px', ''));
      }
    }

    /* =======================
       Mensagens na Tela
       ======================= */

    /* Mostra mensagem temporária (desaparece após X ms) */
    function showTempMessage(text, duration=900, cb){
      msg.textContent = text; 
      msg.classList.remove('hidden');
      setTimeout(()=>{ 
        msg.classList.add('hidden'); 
        if(cb) cb(); // Callback opcional
      }, duration);
    }

    /* Mostra mensagem permanente (até clique) */
    function showMessage(text, isWin=false){
      msg.innerHTML = `<div><strong>${isWin?'Vitória':'Game Over'}</strong><br>${text}<br><small id="restart-hint">Clica / Pressione para recomeçar</small></div>`;
      msg.classList.remove('hidden');
      // Adiciona evento de clique (reinicia jogo) - apenas uma vez
      msg.addEventListener('click', restartMatch, {once:true});
    }

    /* =======================
       Loop Principal do Jogo (Fixed Timestep)
       ======================= */

    /* Loop de jogo (chamado por requestAnimationFrame) */
    function gameLoop(timestamp){
      // Inicializa lastTimestamp
      if(!lastTimestamp) lastTimestamp = timestamp;
      const delta = timestamp - lastTimestamp;
      lastTimestamp = timestamp;
      
      // Se jogo não está rodando, apenas renderiza e agenda próximo frame
      if(!running){ 
        render(0); 
        requestAnimationFrame(gameLoop); 
        return; 
      }

      // Atualiza contadores de animação
      animTimer = Math.floor(timestamp / 200);
      blinkState = Math.floor(timestamp / 600) % 2 === 0;
      mouthOpen = Math.floor(timestamp / 400) % 2 === 0;

      // Acumula tempo e executa updates
      accumulator += delta;
      const maxSteps = 5; // Limite de updates por frame (evita "spiral of death")
      let steps = 0;
      while(accumulator >= timestep && steps < 12){
        update();           // Atualiza lógica do jogo
        accumulator -= timestep;
        steps++;
      }

      // Renderiza com interpolação (suavização)
      const interp = accumulator / timestep;
      render(interp);
      requestAnimationFrame(gameLoop); // Agenda próximo frame
    }

    /* =======================
       Controles e Eventos (incluindo Touch)
       ======================= */

    /* Inicia novo jogo */
    function startGame(){
      startScreen.classList.add('hidden'); // Esconde tela inicial
      msg.classList.add('hidden');
      score = 0; 
      lives = INITIAL_LIVES;
      scoreEl.textContent = score; 
      livesEl.textContent = lives;
      loadHS(); 
      loadLeaderboard();
      resetSnake(); 
      spawnFood();
      invincibleUntil = 0;
      prefs.baseFPS = +speedRange.value;
      timestep = 1000 / prefs.baseFPS; // Ajusta velocidade
      running = true; 
      lastTimestamp = 0; 
      accumulator = 0;
      // Toca música se não estiver mutado
      if(!prefs.muted){
        try{ 
          bgMusic.currentTime = 0; 
          bgMusic.play().catch(()=>{}); 
        }catch(e){}
      }
      requestAnimationFrame(gameLoop);
    }

    /* Reinicia jogo após Game Over ou Vitória */
    function restartMatch(){
      msg.classList.add('hidden');
      resetSnake(); 
      spawnFood();
      score = 0; 
      lives = INITIAL_LIVES;
      scoreEl.textContent = score; 
      livesEl.textContent = lives;
      invincibleUntil = 0;
      prefs.baseFPS = +speedRange.value; 
      timestep = 1000 / prefs.baseFPS;
      running = true; 
      lastTimestamp = 0; 
      accumulator = 0;
      if(!prefs.muted){ 
        try{ 
          bgMusic.currentTime = 0; 
          bgMusic.play().catch(()=>{}); 
        }catch(e){} 
      }
    }

    /* Alterna pausa */
    function togglePause(){
      running = !running;
      pauseBtn.textContent = running ? 'Pausar(Clique P ou Esc)' : 'Retomar(Clique P ou Esc)';
      if(!running) showTempMessage('Pausado', 700);
      else showTempMessage('Retomando', 500);
    }

    /* Atualiza texto do botão de mute */
    function updateMuteButton(){
      muteBtn.textContent = prefs.muted ? 'Música: Off' : 'Música: On';
      document.body.classList.toggle('muted', prefs.muted);
    }

    /* =======================
       Controles por Teclado
       ======================= */

    window.addEventListener('keydown', (e)=>{
      if(e.key === 'p' || e.key === 'P' || e.key === 'Escape'){ 
        togglePause(); 
      }
      if(e.key === 'm' || e.key === 'M'){ 
        prefs.muted = !prefs.muted; 
        applyAudioPrefs(); 
        savePrefs(); 
        updateMuteButton(); 
        if(prefs.muted) bgMusic.pause(); 
        else { 
          try{ 
            bgMusic.play().catch(()=>{}); 
          }catch(e){} 
        } 
      }
      if(e.key === 'r' || e.key === 'R'){ 
        restartMatch(); 
      }
      // Controles de movimento (setas e WASD)
      if(['ArrowUp','w','W'].includes(e.key)){ 
        if(dir.y!==1) nextDir = {x:0,y:-1}; 
      }
      if(['ArrowDown','s','S'].includes(e.key)){ 
        if(dir.y!==-1) nextDir = {x:0,y:1}; 
      }
      if(['ArrowLeft','a','A'].includes(e.key)){ 
        if(dir.x!==1) nextDir = {x:-1,y:0}; 
      }
      if(['ArrowRight','d','D'].includes(e.key)){ 
        if(dir.x!==-1) nextDir = {x:1,y:0}; 
      }
    });

    /* Pausa jogo quando aba perde foco */
    document.addEventListener('visibilitychange', ()=>{
      if(document.hidden && running){ 
        running = false; 
        pauseBtn.textContent = 'Retomar'; 
        showTempMessage('Pausado (aba oculta)', 700); 
      }
    });

    /* =======================
       Eventos de Botões
       ======================= */

    pauseBtn.addEventListener('click', togglePause);
    startBtn.addEventListener('click', ()=>{ startGame(); });
    howBtn.addEventListener('click', ()=>{ 
      showTempMessage('Setas/WASD para mover. Swipe no celular. P/Esc para pausar. M para mutar.', 2200); 
    });

    muteBtn.addEventListener('click', ()=>{
      prefs.muted = !prefs.muted; 
      savePrefs(); 
      applyAudioPrefs();
      if(prefs.muted) { 
        try{ 
          bgMusic.pause(); 
        }catch(e){} 
      }
      else { 
        try{ 
          bgMusic.play().catch(()=>{}); 
        }catch(e){} 
      }
      updateMuteButton();
    });

    /* Sliders (velocidade e volume) */
    speedRange.addEventListener('input', ()=>{
      prefs.baseFPS = +speedRange.value;
      timestep = 1000 / prefs.baseFPS;
      savePrefs();
    });

    volRange.addEventListener('input', ()=>{
      prefs.volume = +volRange.value;
      savePrefs();
      applyAudioPrefs();
    });

    /* Clique na mensagem (Game Over/Vitória) reinicia jogo */
    msg.addEventListener('click', ()=>{ restartMatch(); });

    /* =======================
       Controles Touch (Swipe)
       ======================= */

    let touchStart = null;
    window.addEventListener('touchstart', (e)=>{
      const t = e.touches[0];
      touchStart = {x:t.clientX, y:t.clientY, t:now()};
    });

    window.addEventListener('touchmove', (e)=>{
      if(!touchStart) return;
      const t = e.touches[0];
      const dx = t.clientX - touchStart.x;
      const dy = t.clientY - touchStart.y;
      // Se movimento for significativo (>30px)
      if(Math.abs(dx) > 30 || Math.abs(dy) > 30){
        if(Math.abs(dx) > Math.abs(dy)){ // Movimento horizontal
          if(dx > 0 && dir.x !== -1) nextDir = {x:1,y:0};
          if(dx < 0 && dir.x !== 1) nextDir = {x:-1,y:0};
        } else { // Movimento vertical
          if(dy > 0 && dir.y !== -1) nextDir = {x:0,y:1};
          if(dy < 0 && dir.y !== 1) nextDir = {x:0,y:-1};
        }
        touchStart = null; // Reseta para evitar múltiplos comandos
      }
    });

    /* Previne scroll com setas e espaço */
    window.addEventListener('keydown', e=>{
      if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) 
        e.preventDefault();
    });

    /* =======================
       Controles Touch (Botões Virtuais)
       ======================= */

    // Cada botão do D-Pad e ações
    dpadUp.addEventListener('touchstart', (e) => {
      e.preventDefault(); // Previne comportamento padrão
      if(dir.y !== 1) nextDir = {x:0,y:-1}; // Sobe
    });

    dpadDown.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if(dir.y !== -1) nextDir = {x:0,y:1}; // Desce
    });

    dpadLeft.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if(dir.x !== 1) nextDir = {x:-1,y:0}; // Esquerda
    });

    dpadRight.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if(dir.x !== -1) nextDir = {x:1,y:0}; // Direita
    });

    touchPauseBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      togglePause(); // Pausa/retoma
    });

    touchRestartBtn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      restartMatch(); // Reinicia jogo
    });

    // Previne eventos padrão em todos os elementos touch
    const allTouchElements = document.querySelectorAll('.d-pad-button, .action-button');
    allTouchElements.forEach(el => {
      el.addEventListener('touchstart', e => e.preventDefault());
      el.addEventListener('touchend', e => e.preventDefault());
    });

    /* =======================
       Leaderboard (Placar)
       ======================= */

    /* Renderiza o placar na tela */
    function renderLeaderboard(){
      lbList.innerHTML = '';
      if(!leaderboard || leaderboard.length===0){ 
        lbList.innerHTML = '<div class="small">Nenhum score ainda.</div>'; 
        return;
      }
      leaderboard.forEach((r,i)=>{
        const d = new Date(r.date);
        lbList.innerHTML += `<div style="padding:4px 0">${i+1}. <strong>${r.score}</strong> <span class="small" style="opacity:0.7">(${d.toLocaleString()})</span></div>`;
      });
    }

    /* =======================
       Inicialização
       ======================= */

    /* Função de inicialização (carrega preferências, configura canvas, etc) */
    function init(){
      loadPrefs(); 
      loadHS(); 
      loadLeaderboard();
      setupCanvas();
      setupAudio();
      volRange.value = prefs.volume;
      speedRange.value = prefs.baseFPS || 10;
      updateMuteButton();
      applyAudioPrefs();

      resetSnake(); 
      spawnFood();
      render(0); // Renderiza frame inicial

      requestAnimationFrame(gameLoop);
    }

    /* Inicia o jogo */
    init();

    /* Ajusta canvas ao redimensionar janela */
    window.addEventListener('resize', ()=>{
      setupCanvas(); 
      drawChessboardToCache(); 
      render(0);
    });

  </script>
</body>
</html>
